== [[ContinuousExecution]] ContinuousExecution -- StreamExecution of Continuous Stream Processing

`ContinuousExecution` is the <<spark-sql-streaming-StreamExecution.adoc#, StreamExecution>> of <<spark-sql-streaming-continuous-stream-processing.adoc#, Continuous Stream Processing>>.

`ContinuousExecution` is <<creating-instance, created>> when `StreamingQueryManager` is requested to <<spark-sql-streaming-StreamingQueryManager.adoc#createQuery, create a streaming query>> with a <<sink, StreamWriteSupport sink>> and a <<trigger, ContinuousTrigger>> (when `DataStreamWriter` is requested to <<spark-sql-streaming-DataStreamWriter.adoc#start, start an execution of the streaming query>>).

`ContinuousExecution` can only run streaming queries with <<spark-sql-streaming-StreamingRelationV2.adoc#, StreamingRelationV2>> with <<spark-sql-streaming-ContinuousReadSupport.adoc#, ContinuousReadSupport>> data source.

[[sources]]
`ContinuousExecution` supports one <<continuousSources, ContinuousReader>> in a <<logicalPlan, streaming query>> only (and asserts it when <<addOffset, addOffset>> and <<commit, committing an epoch>>). When requested for available <<spark-sql-streaming-ProgressReporter.adoc#sources, streaming sources>>, `ContinuousExecution` simply gives the <<continuousSources, single ContinuousReader>>.

[source, scala]
----
import org.apache.spark.sql.streaming.Trigger
import scala.concurrent.duration._
val sq = spark
  .readStream
  .format("rate")
  .load
  .writeStream
  .format("console")
  .option("truncate", false)
  .trigger(Trigger.Continuous(1.minute)) // <-- Gives ContinuousExecution
  .queryName("rate2console")
  .start

import org.apache.spark.sql.streaming.StreamingQuery
assert(sq.isInstanceOf[StreamingQuery])

// The following gives access to the internals
// And to ContinuousExecution
import org.apache.spark.sql.execution.streaming.StreamingQueryWrapper
val engine = sq.asInstanceOf[StreamingQueryWrapper].streamingQuery
import org.apache.spark.sql.execution.streaming.StreamExecution
assert(engine.isInstanceOf[StreamExecution])

import org.apache.spark.sql.execution.streaming.continuous.ContinuousExecution
val continuousEngine = engine.asInstanceOf[ContinuousExecution]
assert(continuousEngine.trigger == Trigger.Continuous(1.minute))
----

When <<creating-instance, created>> (for a streaming query), `ContinuousExecution` is given the <<analyzedPlan, analyzed logical plan>>. The analyzed logical plan is immediately transformed to include a <<spark-sql-streaming-ContinuousExecutionRelation.adoc#, ContinuousExecutionRelation>> for every <<spark-sql-streaming-StreamingRelationV2.adoc#, StreamingRelationV2>> with <<spark-sql-streaming-ContinuousReadSupport.adoc#, ContinuousReadSupport>> data source (and is the <<logicalPlan, logical plan>> internally).

NOTE: `ContinuousExecution` uses the same instance of `ContinuousExecutionRelation` for the same instances of <<spark-sql-streaming-StreamingRelationV2.adoc#, StreamingRelationV2>> with <<spark-sql-streaming-ContinuousReadSupport.adoc#, ContinuousReadSupport>> data source.

When requested to <<runContinuous, run the streaming query>>, `ContinuousExecution` collects <<spark-sql-streaming-ContinuousReadSupport.adoc#, ContinuousReadSupport>> data sources (inside <<spark-sql-streaming-ContinuousExecutionRelation.adoc#, ContinuousExecutionRelation>>) from the <<logicalPlan, analyzed logical plan>> and requests each and every `ContinuousReadSupport` to <<spark-sql-streaming-ContinuousReadSupport.adoc#createContinuousReader, create a ContinuousReader>> (that are stored in <<continuousSources, continuousSources>> internal registry).

[[EPOCH_COORDINATOR_ID_KEY]]
`ContinuousExecution` uses *__epoch_coordinator_id* local property for...FIXME

[[START_EPOCH_KEY]]
`ContinuousExecution` uses *__continuous_start_epoch* local property for...FIXME

[[logging]]
[TIP]
====
Enable `ALL` logging level for `org.apache.spark.sql.execution.streaming.continuous.ContinuousExecution` to see what happens inside.

Add the following line to `conf/log4j.properties`:

```
log4j.logger.org.apache.spark.sql.execution.streaming.continuous.ContinuousExecution=ALL
```

Refer to <<spark-sql-streaming-logging.adoc#, Logging>>.
====

=== [[runActivatedStream]] Running Activated Streaming Query -- `runActivatedStream` Method

[source, scala]
----
runActivatedStream(sparkSessionForStream: SparkSession): Unit
----

NOTE: `runActivatedStream` is part of <<spark-sql-streaming-StreamExecution.adoc#runActivatedStream, StreamExecution Contract>> to run a streaming query.

`runActivatedStream` simply <<runContinuous, runs the streaming query in continuous mode>> as long as the <<spark-sql-streaming-StreamExecution.adoc#state, state>> is <<spark-sql-streaming-StreamExecution.adoc#ACTIVE, ACTIVE>>.

=== [[runContinuous]] Running Streaming Query in Continuous Mode -- `runContinuous` Internal Method

[source, scala]
----
runContinuous(sparkSessionForQuery: SparkSession): Unit
----

`runContinuous` initializes the <<continuousSources, continuousSources>> internal registry by traversing the <<logicalPlan, analyzed logical plan>> to find <<spark-sql-streaming-ContinuousExecutionRelation.adoc#, ContinuousExecutionRelation>> leaf logical operators and requests their <<spark-sql-streaming-ContinuousReadSupport.adoc#, ContinuousReadSupport data sources>> to <<spark-sql-streaming-ContinuousReadSupport.adoc#createContinuousReader, create a ContinuousReader>> (with the *sources* metadata directory under the <<spark-sql-streaming-StreamExecution.adoc#resolvedCheckpointRoot, checkpoint directory>>).

`runContinuous` initializes the <<spark-sql-streaming-StreamExecution.adoc#uniqueSources, uniqueSources>> internal registry to be the <<continuousSources, continuousSources>> distinct.

`runContinuous` <<getStartOffsets, gets the start offsets>> (they may or may not be available).

`runContinuous` transforms the <<logicalPlan, analyzed logical plan>>. For every <<spark-sql-streaming-ContinuousExecutionRelation.adoc#, ContinuousExecutionRelation>> `runContinuous` finds the corresponding <<spark-sql-streaming-ContinuousReader.adoc#, ContinuousReader>> (in the <<continuousSources, continuousSources>>), requests it to <<spark-sql-streaming-ContinuousReader.adoc#deserializeOffset, deserialize the start offsets>> (from their JSON representation), and then <<spark-sql-streaming-ContinuousReader.adoc#setStartOffset, setStartOffset>>. In the end, `runContinuous` creates a `StreamingDataSourceV2Relation` (with the read schema of the `ContinuousReader` and the `ContinuousReader` itself).

`runContinuous` rewires the transformed plan (with the `StreamingDataSourceV2Relation`) to use the new attributes from the source (the reader).

NOTE: `CurrentTimestamp` and `CurrentDate` expressions are not supported for continuous processing.

`runContinuous` requests the <<sink, StreamWriteSupport>> to <<spark-sql-streaming-StreamWriteSupport.adoc#createStreamWriter, create a StreamWriter>> (with the <<spark-sql-streaming-StreamExecution.adoc#runId, run ID of the streaming query>>).

`runContinuous` creates a <<spark-sql-streaming-WriteToContinuousDataSource.adoc#, WriteToContinuousDataSource>> (with the <<spark-sql-streaming-StreamWriter.adoc#, StreamWriter>> and the transformed logical query plan).

`runContinuous` finds the only <<spark-sql-streaming-ContinuousReader.adoc#, ContinuousReader>> (of the only `StreamingDataSourceV2Relation`) in the query plan with the `WriteToContinuousDataSource`.

In *queryPlanning* <<spark-sql-streaming-ProgressReporter.adoc#reportTimeTaken, time-tracking section>>, `runContinuous` creates a <<spark-sql-streaming-IncrementalExecution.adoc#, IncrementalExecution>> (that becomes the <<spark-sql-streaming-StreamExecution.adoc#lastExecution, lastExecution>>) that is immediately executed (i.e. the entire query execution pipeline is executed with no internal RDD generation).

`runContinuous`...FIXME

NOTE: `runContinuous` is used exclusively when `ContinuousExecution` is requested to <<runActivatedStream, run an activated streaming query>>.

==== [[getStartOffsets]] Retrieving Start Offsets -- `getStartOffsets` Internal Method

[source, scala]
----
getStartOffsets(sparkSessionToRunBatches: SparkSession): OffsetSeq
----

`getStartOffsets`...FIXME

NOTE: `getStartOffsets` is used exclusively when `ContinuousExecution` is requested to <<runContinuous, run a streaming query in continuous mode>>.

=== [[commit]] Committing Epoch -- `commit` Method

[source, scala]
----
commit(epoch: Long): Unit
----

`commit`...FIXME

NOTE: `commit` is used exclusively when `EpochCoordinator` is requested to <<spark-sql-streaming-EpochCoordinator.adoc#commitEpoch, commitEpoch>>.

=== [[addOffset]] `addOffset` Method

[source, scala]
----
addOffset(
  epoch: Long,
  reader: ContinuousReader,
  partitionOffsets: Seq[PartitionOffset]): Unit
----

In essense, `addOffset` requests the given <<spark-sql-streaming-ContinuousReader.adoc#, ContinuousReader>> to <<spark-sql-streaming-ContinuousReader.adoc#mergeOffsets, mergeOffsets>> (with the given `PartitionOffsets`) and then requests the <<spark-sql-streaming-StreamExecution.adoc#offsetLog, OffsetSeqLog>> to <<spark-sql-streaming-HDFSMetadataLog.adoc#add, register the offset with the given epoch>>.

.ContinuousExecution.addOffset
image::images/ContinuousExecution-addOffset.png[align="center"]

Internally, `addOffset` requests the given <<spark-sql-streaming-ContinuousReader.adoc#, ContinuousReader>> to <<spark-sql-streaming-ContinuousReader.adoc#mergeOffsets, mergeOffsets>> (with the given `PartitionOffsets`) and to get the current "global" offset back.

`addOffset` then requests the <<spark-sql-streaming-StreamExecution.adoc#offsetLog, OffsetSeqLog>> to <<spark-sql-streaming-HDFSMetadataLog.adoc#add, add>> the current "global" offset for the given `epoch`.

`addOffset` requests the <<spark-sql-streaming-StreamExecution.adoc#offsetLog, OffsetSeqLog>> for the <<spark-sql-streaming-HDFSMetadataLog.adoc#get, offset at the previous epoch>>.

If the offsets at the current and previous epochs are the same, `addOffset` turns the <<spark-sql-streaming-StreamExecution.adoc#noNewData, noNewData>> internal flag on.

`addOffset` then acquires the <<spark-sql-streaming-StreamExecution.adoc#awaitProgressLock, awaitProgressLock>>, wakes up all threads waiting for the <<spark-sql-streaming-StreamExecution.adoc#awaitProgressLockCondition, awaitProgressLockCondition>> and in the end releases the <<spark-sql-streaming-StreamExecution.adoc#awaitProgressLock, awaitProgressLock>>.

NOTE: `addOffset` supports exactly one <<continuousSources, continuous source>>.

NOTE: `addOffset` is used exclusively when `EpochCoordinator` is requested to <<spark-sql-streaming-EpochCoordinator.adoc#ReportPartitionOffset, handle a ReportPartitionOffset message>>.

=== [[logicalPlan]] Analyzed Logical Plan of Streaming Query -- `logicalPlan` Property

[source, scala]
----
logicalPlan: LogicalPlan
----

NOTE: `logicalPlan` is part of <<spark-sql-streaming-StreamExecution.adoc#logicalPlan, StreamExecution Contract>> that is the analyzed logical plan of the streaming query.

`logicalPlan` resolves <<spark-sql-streaming-StreamingRelationV2.adoc#, StreamingRelationV2>> leaf logical operators (with a <<spark-sql-streaming-ContinuousReadSupport.adoc#, ContinuousReadSupport>> source) to <<spark-sql-streaming-ContinuousExecutionRelation.adoc#, ContinuousExecutionRelation>> leaf logical operators.

Internally, `logicalPlan` transforms the <<analyzedPlan, analyzed logical plan>> as follows:

. For every <<spark-sql-streaming-StreamingRelationV2.adoc#, StreamingRelationV2>> leaf logical operator with a <<spark-sql-streaming-ContinuousReadSupport.adoc#, ContinuousReadSupport>> source, `logicalPlan` looks it up for the corresponding <<spark-sql-streaming-ContinuousExecutionRelation.adoc#, ContinuousExecutionRelation>> (if available in the internal lookup registry) or creates a `ContinuousExecutionRelation` (with the `ContinuousReadSupport` source, the options and the output attributes of the `StreamingRelationV2` operator)

. For any other `StreamingRelationV2`, `logicalPlan` throws an `UnsupportedOperationException`:
+
```
Data source [name] does not support continuous processing.
```

=== [[creating-instance]] Creating ContinuousExecution Instance

`ContinuousExecution` takes the following when created:

* [[sparkSession]] `SparkSession`
* [[name]] The name of the structured query
* [[checkpointRoot]] Path to the checkpoint directory (aka _metadata directory_)
* [[analyzedPlan]] Analyzed logical query plan (`LogicalPlan`)
* [[sink]] <<spark-sql-streaming-StreamWriteSupport.adoc#, StreamWriteSupport>>
* [[trigger]] <<spark-sql-streaming-Trigger.adoc#, Trigger>>
* [[triggerClock]] `Clock`
* [[outputMode]] <<spark-sql-streaming-OutputMode.adoc#, Output mode>>
* [[extraOptions]] Options (`Map[String, String]`)
* [[deleteCheckpointOnStop]] `deleteCheckpointOnStop` flag to control whether to delete the checkpoint directory on stop

`ContinuousExecution` initializes the <<internal-properties, internal properties>>.

=== [[stop]] Stopping Streaming Query -- `stop` Method

[source, scala]
----
stop(): Unit
----

NOTE: `stop` is part of the <<spark-sql-streaming-StreamingQuery.adoc#stop, StreamingQuery Contract>> to stop a streaming query.

`stop` transitions the streaming query to `TERMINATED` state.

If the <<spark-sql-streaming-StreamExecution.adoc#queryExecutionThread, queryExecutionThread>> is alive (i.e. it has been started and has not yet died), `stop` interrupts it and waits for this thread to die.

In the end, `stop` prints out the following INFO message to the logs:

```
Query [prettyIdString] was stopped
```

NOTE: <<spark-sql-streaming-StreamExecution.adoc#prettyIdString, prettyIdString>> is in the format of `queryName [id = [id], runId = [runId]]`.

=== [[awaitEpoch]] `awaitEpoch` Internal Method

[source, scala]
----
awaitEpoch(epoch: Long): Unit
----

`awaitEpoch`...FIXME

NOTE: `awaitEpoch` seems to be used exclusively in tests.

=== [[internal-properties]] Internal Properties

[cols="30m,70",options="header",width="100%"]
|===
| Name
| Description

| continuousSources
a| [[continuousSources]]

[source, scala]
----
continuousSources: Seq[ContinuousReader]
----

Registry of <<spark-sql-streaming-ContinuousReader.adoc#, ContinuousReaders>> (in the <<logicalPlan, analyzed logical plan of the streaming query>>)

Used when `ContinuousExecution` is requested to <<commit, commit>>, <<getStartOffsets, getStartOffsets>>, and <<runContinuous, runContinuous>>

Use <<sources, sources>> to access the current value

| currentEpochCoordinatorId
| [[currentEpochCoordinatorId]] FIXME

Used when...FIXME

| triggerExecutor
a| [[triggerExecutor]] <<spark-sql-streaming-TriggerExecutor.adoc#, TriggerExecutor>> for the <<trigger, Trigger>>:

* `ProcessingTimeExecutor` for <<spark-sql-streaming-Trigger.adoc#ContinuousTrigger, ContinuousTrigger>>

Used when...FIXME

NOTE: `StreamExecution` throws an `IllegalStateException` when the <<trigger, Trigger>> is not a <<spark-sql-streaming-Trigger.adoc#ContinuousTrigger, ContinuousTrigger>>.
|===
